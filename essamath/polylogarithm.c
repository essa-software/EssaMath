#include "polylogarithm.h"
#include "math_utils.h"
#include <float.h>
#include <complex.h>
#include <limits.h>
#include <math.h>
#include <stdint.h>

#undef I
#define I (__extension__ 1.0i)

#undef CMPLX
#define CMPLX(x, y) ((double complex)((double)(x) + I * (double)(y)))

double _Complex em_clog1p(double _Complex z)
{
   const double _Complex u = 1.0 + z;
   const double rz = creal(u);
   const double iz = cimag(u);

   if (rz == 1.0 && iz == 0.0) {
      return z;
   } 
   
   if (rz <= 0.0) {
      return clog(u);
   }

   return clog(u)*(z/(u - 1.0));
}

double em_li2(double x)
{
   const double PI = 3.1415926535897932;
   const double P[] = {
      0.9999999999999999502e+0,
     -2.6883926818565423430e+0,
      2.6477222699473109692e+0,
     -1.1538559607887416355e+0,
      2.0886077795020607837e-1,
     -1.0859777134152463084e-2
   };
   const double Q[] = {
      1.0000000000000000000e+0,
     -2.9383926818565635485e+0,
      3.2712093293018635389e+0,
     -1.7076702173954289421e+0,
      4.1596017228400603836e-1,
     -3.9801343754084482956e-2,
      8.2743668974466659035e-4
   };

   double y = 0, r = 0, s = 1;

   /* transform to [0, 1/2] */
   if (x < -1) {
      const double l = log(1 - x);
      y = 1/(1 - x);
      r = -PI*PI/6 + l*(0.5*l - log(-x));
      s = 1;
   } else if (x == -1) {
      return -PI*PI/12;
   } else if (x < 0) {
      const double l = log1p(-x);
      y = x/(x - 1);
      r = -0.5*l*l;
      s = -1;
   } else if (x == 0) {
      return x;
   } else if (x < 0.5) {
      y = x;
      r = 0;
      s = 1;
   } else if (x < 1) {
      y = 1 - x;
      r = PI*PI/6 - log(x)*log1p(-x);
      s = -1;
   } else if (x == 1) {
      return PI*PI/6;
   } else if (x < 2) {
      const double l = log(x);
      y = 1 - 1/x;
      r = PI*PI/6 - l*(log(y) + 0.5*l);
      s = 1;
   } else {
      const double l = log(x);
      y = 1/x;
      r = PI*PI/3 - 0.5*l*l;
      s = -1;
   }

   const double y2 = y*y;
   const double y4 = y2*y2;
   const double p = P[0] + y * P[1] + y2 * (P[2] + y * P[3]) +
                    y4 * (P[4] + y * P[5]);
   const double q = Q[0] + y * Q[1] + y2 * (Q[2] + y * Q[3]) +
                    y4 * (Q[4] + y * Q[5] + y2 * Q[6]);

   return r + s*y*p/q;
}

double _Complex em_cli2(double _Complex z)
{
   const double PI = 3.1415926535897932;

   /* bf[1..N-1] are the even Bernoulli numbers / (2 n + 1)! */
   /* generated by: Table[BernoulliB[2 n]/(2 n + 1)!, {n, 1, 9}] */
   const double bf[10] = {
      - 1.0/4.0,
      + 1.0/36.0,
      - 1.0/3600.0,
      + 1.0/211680.0,
      - 1.0/10886400.0,
      + 1.0/526901760.0,
      - 4.0647616451442255e-11,
      + 8.9216910204564526e-13,
      - 1.9939295860721076e-14,
      + 4.5189800296199182e-16
   };

   const double rz = creal(z);
   const double iz = cimag(z);

   /* special cases */
   if (iz == 0.0) {
      if (rz <= 1.0) {
         return CMPLX(em_li2(rz), iz);
      }
      // rz > 1.0
      return CMPLX(em_li2(rz), -PI*log(rz));
   }

   const double nz = rz*rz + iz*iz;

   if (nz < DBL_EPSILON) {
      return z*(1.0 + 0.25*z);
   }

   double _Complex u = 0.0, rest = 0.0;
   double sgn = 1;

   /* transformation to |z|<1, Re(z)<=0.5 */
   if (rz <= 0.5) {
      if (nz > 1.0) {
         const double _Complex lz = clog(-z);
         u = -em_clog1p(-1.0/z);
         rest = -0.5*lz*lz - PI*PI/6;
         sgn = -1;
      } else { /* nz <= 1 */
         u = -em_clog1p(-z);
         rest = 0;
         sgn = 1;
      }
   } else { /* rz > 0.5 */
      if (nz <= 2*rz) {
         u = -clog(z);
         rest = u*em_clog1p(-z) + PI*PI/6;
         sgn = -1;
      } else { /* nz > 2*rz */
         const double _Complex lz = clog(-z);
         u = -em_clog1p(-1.0/z);
         rest = -0.5*lz*lz - PI*PI/6;
         sgn = -1;
      }
   }

   const double _Complex u2 = u*u;
   const double _Complex u4 = u2*u2;
   const double _Complex sum =
      u +
      u2 * (bf[0] +
      u  * (bf[1] +
      u2 * (
          bf[2] +
          u2*bf[3] +
          u4*(bf[4] + u2*bf[5]) +
          u4*u4*(bf[6] + u2*bf[7] + u4*(bf[8] + u2*bf[9]))
      )));

   return sgn * sum + rest;
}

static double li3_neg(double x)
{
   const double cp[] = {
      0.9999999999999999795e+0, -2.0281801754117129576e+0,
      1.4364029887561718540e+0, -4.2240680435713030268e-1,
      4.7296746450884096877e-2, -1.3453536579918419568e-3
   };
   const double cq[] = {
      1.0000000000000000000e+0, -2.1531801754117049035e+0,
      1.6685134736461140517e+0, -5.6684857464584544310e-1,
      8.1999463370623961084e-2, -4.0756048502924149389e-3,
      3.4316398489103212699e-5
   };

   const double x2 = x*x;
   const double x4 = x2*x2;
   const double p = cp[0] + x*cp[1] + x2*(cp[2] + x*cp[3]) +
      x4*(cp[4] + x*cp[5]);
   const double q = cq[0] + x*cq[1] + x2*(cq[2] + x*cq[3]) +
      x4*(cq[4] + x*cq[5] + x2*cq[6]);

   return x*p/q;
}

/// Li_3(x) for x in [0,1/2]
static double li3_pos(double x)
{
   const double cp[] = {
      0.9999999999999999893e+0, -2.5224717303769789628e+0,
      2.3204919140887894133e+0, -9.3980973288965037869e-1,
      1.5728950200990509052e-1, -7.5485193983677071129e-3
   };
   const double cq[] = {
      1.0000000000000000000e+0, -2.6474717303769836244e+0,
      2.6143888433492184741e+0, -1.1841788297857667038e+0,
      2.4184938524793651120e-1, -1.8220900115898156346e-2,
      2.4927971540017376759e-4
   };

   const double x2 = x*x;
   const double x4 = x2*x2;
   const double p = cp[0] + x*cp[1] + x2*(cp[2] + x*cp[3]) +
      x4*(cp[4] + x*cp[5]);
   const double q = cq[0] + x*cq[1] + x2*(cq[2] + x*cq[3]) +
      x4*(cq[4] + x*cq[5] + x2*cq[6]);

   return x*p/q;
}

double em_li3(double x)
{
   const double zeta2 = 1.6449340668482264;
   const double zeta3 = 1.2020569031595943;

   // transformation to [-1,0] and [0,1/2]
   if (x < -1) {
      const double l = log(-x);
      return li3_neg(1/x) - l*(zeta2 + 1.0/6*l*l);
   } if (x == -1) {
      return -0.75*zeta3;
   } if (x < 0) {
      return li3_neg(x);
   } if (x == 0) {
      return x;
   } if (x < 0.5) {
      return li3_pos(x);
   } if (x == 0.5) {
      return 0.53721319360804020;
   } if (x < 1) {
      const double l = log(x);
      return -li3_neg(1 - 1/x) - li3_pos(1 - x)
         + zeta3 + l*(zeta2 + l*(-0.5*log1p(-x) + 1.0/6*l));
   } if (x == 1) {
      return zeta3;
   } if (x < 2) {
      const double l = log(x);
      return -li3_neg(1 - x) - li3_pos(1 - 1/x)
         + zeta3 + l*(zeta2 + l*(-0.5*log(x - 1) + 1.0/6*l));
   }  // x >= 2.0
      const double l = log(x);
      return li3_pos(1/x) + l*(2*zeta2 - 1.0/6*l*l);
  
}

double _Complex pos_clog(double _Complex z)
{
   const double rz = creal(z);
   const double iz = cimag(z);

   if (iz == 0.0 && rz > 0.0) {
      return log(rz);
   } else if (iz == 0.0) {
      return log(-rz) + I*3.1415926535897932;
   }

   return clog(z);
}

double _Complex em_cli3(double _Complex z)
{
   const double PI    = 3.1415926535897932;
   const double zeta2 = 1.6449340668482264;
   const double zeta3 = 1.2020569031595943;
   const double bf[18] = {
      1.0                   , -3.0/8.0               ,
      17.0/216.0            , -5.0/576.0             ,
      1.2962962962962963e-04,  8.1018518518518519e-05,
     -3.4193571608537595e-06, -1.3286564625850340e-06,
      8.6608717561098513e-08,  2.5260875955320400e-08,
     -2.1446944683640648e-09, -5.1401106220129789e-10,
      5.2495821146008294e-11,  1.0887754406636318e-11,
     -1.2779396094493695e-12, -2.3698241773087452e-13,
      3.1043578879654623e-14,  5.2617586299125061e-15
   };

   const double rz  = creal(z);
   const double iz  = cimag(z);

   if (iz == 0) {
      if (rz <= 1) {
         return CMPLX(em_li3(rz), iz);
      } else {
         const double l = log(rz);
         return CMPLX(em_li3(rz), -0.5*PI*l*l);
      }
   }

   const double nz  = hypot(rz, iz);
   const double pz  = atan2(iz, rz);
   const double lnz = log(nz);

   if (lnz*lnz + pz*pz < 1.0) { // |log(z)| < 1
      const double _Complex u  = lnz + pz*I; // clog(z)
      const double _Complex u2 = u*u;
      const double _Complex u4 = u2*u2;
      const double _Complex u8 = u4*u4;
      const double _Complex c0 = zeta3 + u*(zeta2 - u2/12.0);
      const double _Complex c1 = 0.25 * (3.0 - 2.0*pos_clog(-u));

      const double cs[7] = {
         -3.4722222222222222e-03, 1.1574074074074074e-05,
         -9.8418997228521038e-08, 1.1482216343327454e-09,
         -1.5815724990809166e-11, 2.4195009792525152e-13,
         -3.9828977769894877e-15
      };

      return
         c0 +
         c1*u2 +
         u4*(cs[0] + u2*cs[1]) +
         u8*(cs[2] + u2*cs[3] + u4*(cs[4] + u2*cs[5])) +
         u8*u8*cs[6];
   }

   double _Complex u = 0.0, rest = 0.0;

   if (nz <= 1.0) {
      u = -pos_clog(1.0 - z);
   } else { // nz > 1
      const double arg = pz > 0.0 ? pz - PI : pz + PI;
      const double _Complex lmz = lnz + arg*I; // clog(-z)
      u = -pos_clog(1.0 - 1.0/z);
      rest = -lmz*(lmz*lmz/6.0 + zeta2);
   }

   const double _Complex u2 = u*u;
   const double _Complex u4 = u2*u2;
   const double _Complex u8 = u4*u4;

   return
      rest +
      u*bf[0] +
      u2*(bf[1] + u*bf[2]) +
      u4*(bf[3] + u*bf[4] + u2*(bf[5] + u*bf[6])) +
      u8*(bf[7] + u*bf[8] + u2*(bf[9] + u*bf[10]) +
          u4*(bf[11] + u*bf[12] + u2*(bf[13] + u*bf[14]))) +
      u8*u8*(bf[15] + u*bf[16] + u2*bf[17]);
}

/// Li_4(x) for x in [-1,0]
static double li4_neg(double x)
{
   const double cp[] = {
      0.9999999999999999952e+0, -1.8532099956062184217e+0,
      1.1937642574034898249e+0, -3.1817912243893560382e-1,
      3.2268284189261624841e-2, -8.3773570305913850724e-4
   };
   const double cq[] = {
      1.0000000000000000000e+0, -1.9157099956062165688e+0,
      1.3011504531166486419e+0, -3.7975653506939627186e-1,
      4.5822723996558783670e-2, -1.8023912938765272341e-3,
      1.0199621542882314929e-5
   };

   const double x2 = x*x;
   const double x4 = x2*x2;
   const double p = cp[0] + x*cp[1] + x2*(cp[2] + x*cp[3]) +
      x4*(cp[4] + x*cp[5]);
   const double q = cq[0] + x*cq[1] + x2*(cq[2] + x*cq[3]) +
      x4*(cq[4] + x*cq[5] + x2*cq[6]);

   return x*p/q;
}

/// Li_4(x) for x in [0,1/2]
static double li4_half(double x)
{
   const double cp[] = {
      1.0000000000000000414e+0, -2.0588072418045364525e+0,
      1.4713328756794826579e+0, -4.2608608613069811474e-1,
      4.2975084278851543150e-2, -6.8314031819918920802e-4
   };
   const double cq[] = {
      1.0000000000000000000e+0, -2.1213072418045207223e+0,
      1.5915688992789175941e+0, -5.0327641401677265813e-1,
      6.1467217495127095177e-2, -1.9061294280193280330e-3
   };

   const double x2 = x*x;
   const double x4 = x2*x2;
   const double p = cp[0] + x*cp[1] + x2*(cp[2] + x*cp[3]) +
      x4*(cp[4] + x*cp[5]);
   const double q = cq[0] + x*cq[1] + x2*(cq[2] + x*cq[3]) +
      x4*(cq[4] + x*cq[5]);

   return x*p/q;
}

/// Li_4(x) for x in [1/2,8/10]
static double li4_mid(double x)
{
   const double cp[] = {
       3.2009826406098890447e-9, 9.9999994634837574160e-1,
      -2.9144851228299341318e+0, 3.1891031447462342009e+0,
      -1.6009125158511117090e+0, 3.5397747039432351193e-1,
      -2.5230024124741454735e-2
   };
   const double cq[] = {
      1.0000000000000000000e+0, -2.9769855248411488460e+0,
      3.3628208295110572579e+0, -1.7782471949702788393e+0,
      4.3364007973198649921e-1, -3.9535592340362510549e-2,
      5.7373431535336755591e-4
   };

   const double x2 = x*x;
   const double x4 = x2*x2;
   const double p = cp[0] + x*cp[1] + x2*(cp[2] + x*cp[3]) +
      x4*(cp[4] + x*cp[5] + x2*cp[6]);
   const double q = cq[0] + x*cq[1] + x2*(cq[2] + x*cq[3]) +
      x4*(cq[4] + x*cq[5] + x2*cq[6]);

   return p/q;
}

/// Li_4(x) for x in [8/10,1]
static double li4_one(double x)
{
   const double zeta2 = 1.6449340668482264;
   const double zeta3 = 1.2020569031595943;
   const double zeta4 = 1.0823232337111382;
   const double l = log(x);
   const double l2 = l*l;

   return zeta4 +
      l*(zeta3 +
      l*(0.5*zeta2 +
      l*(11.0/36 - 1.0/6*log(-l) +
      l*(-1.0/48 +
      l*(-1.0/1440 +
      l2*(1.0/604800 - 1.0/91445760*l2))))));
}

double em_li4(double x)
{
   const double zeta2 = 1.6449340668482264;
   const double zeta4 = 1.0823232337111382;

   double app = 0, rest = 0, sgn = 1;

   // transform x to [-1,1]
   if (x < -1) {
      const double l = log(-x);
      const double l2 = l*l;
      x = 1/x;
      rest = -7.0/4*zeta4 + l2*(-0.5*zeta2 - 1.0/24*l2);
      sgn = -1;
   } else if (x == -1) {
      return -7.0/8*zeta4;
   } else if (x == 0) {
      return x;
   } else if (x < 1) {
      rest = 0;
      sgn = 1;
   } else if (x == 1) {
      return zeta4;
   } else { // x > 1
      const double l = log(x);
      const double l2 = l*l;
      x = 1/x;
      rest = 2*zeta4 + l2*(zeta2 - 1.0/24*l2);
      sgn = -1;
   }

   if (x < 0) {
      app = li4_neg(x);
   } else if (x < 0.5) {
      app = li4_half(x);
   } else if (x < 0.8) {
      app = li4_mid(x);
   } else { // x <= 1
      app = li4_one(x);
   }

   return rest + sgn*app;
}

double _Complex em_cli4(double _Complex z)
{
   const double PI    = 3.1415926535897932;
   const double PI2   = PI*PI;
   const double PI4   = PI2*PI2;
   const double zeta4 = 1.0823232337111382;
   const double bf[18] = {
      1.0                   , -7.0/16.0              ,
      1.1651234567901235e-01, -1.9820601851851852e-02,
      1.9279320987654321e-03, -3.1057098765432099e-05,
     -1.5624009114857835e-05,  8.4851235467732066e-07,
      2.2909616603189711e-07, -2.1832614218526917e-08,
     -3.8828248791720156e-09,  5.4462921032203321e-10,
      6.9608052106827254e-11, -1.3375737686445215e-11,
     -1.2784852685266572e-12,  3.2605628580248922e-13,
      2.3647571168618257e-14, -7.9231351220311617e-15
   };

   const double rz  = creal(z);
   const double iz  = cimag(z);

   if (iz == 0) {
      if (rz <= 1) {
         return CMPLX(em_li4(rz), iz);
      } else {
         const double l = log(rz);
         return CMPLX(em_li4(rz), -1.0/6*PI*l*l*l);
      }
   }

   const double nz  = hypot(rz, iz);
   const double pz  = atan2(iz, rz);
   const double lnz = log(nz);

   if (lnz*lnz + pz*pz < 1.0) { // |log(z)| < 1
      const double _Complex u = lnz + pz*I; // clog(z)
      const double _Complex u2 = u*u;
      const double _Complex u4 = u2*u2;
      const double _Complex u8 = u4*u4;
      const double c1 = 1.2020569031595943; // em_zeta(3)
      const double c2 = 0.82246703342411322;
      const double _Complex c3 = (11.0/6.0 - pos_clog(-u))/6.0;
      const double c4 = -1.0/48.0;

      const double cs[7] = {
         -6.9444444444444444e-04, 1.6534391534391534e-06,
         -1.0935444136502338e-08, 1.0438378493934049e-10,
         -1.2165942300622435e-12, 1.6130006528350101e-14,
         -2.3428810452879340e-16
      };

      return zeta4 + u2 * (c2 + u2 * c4) +
          u * (
              c1 +
              c3*u2 +
              u4*(cs[0] + u2*cs[1]) +
              u8*(cs[2] + u2*cs[3] + u4*(cs[4] + u2*cs[5])) +
              u8*u8*cs[6]
          );
   }

   double _Complex u = 0.0, r = 0.0;
   double sgn = 1;

   if (nz <= 1.0) {
      u = -pos_clog(1.0 - z);
   } else { // nz > 1
      const double arg = pz > 0.0 ? pz - PI : pz + PI;
      const double _Complex lmz = lnz + arg*I; // clog(-z)
      const double _Complex lmz2 = lmz*lmz;
      u = -pos_clog(1.0 - 1.0/z);
      r = 1.0/360.0*(-7*PI4 + lmz2*(-30.0*PI2 - 15.0*lmz2));
      sgn = -1;
   }

   const double _Complex u2 = u*u;
   const double _Complex u4 = u2*u2;
   const double _Complex u8 = u4*u4;

   return
      r + sgn * (
         u*bf[0] +
         u2*(bf[1] + u*bf[2]) +
         u4*(bf[3] + u*bf[4] + u2*(bf[5] + u*bf[6])) +
         u8*(bf[7] + u*bf[8] + u2*(bf[9] + u*bf[10]) +
             u4*(bf[11] + u*bf[12] + u2*(bf[13] + u*bf[14]))) +
         u8*u8*(bf[15] + u*bf[16] + u2*bf[17])
      );
}

double inf = (__builtin_inf ());
double PI = 3.1415926535897932;

int64_t is_finite(double _Complex z)
{
    return isfinite(creal(z)) && isfinite(cimag(z));
}

 /// Series expansion of Li_n(z) in terms of powers of z.
 /// Fast convergence for large n >= 12.
 double _Complex Li_series(int64_t n, double _Complex z)
{
    double _Complex sum = 0.0, sum_old = 0.0, p = z;
    int64_t k = 0;

    do {
        k++;
        sum_old = sum;
        sum += p;
        p *= z*pow(((double)k)/(1.0 + (double)k), (double)n);
        if (!is_finite(p)) { break; }
    } while (sum != sum_old && k < LONG_MAX - 2);

    return sum;
}

/// Series expansion of Li_n(z) around z ~ 1, n > 0
double _Complex Li_unity_pos(int64_t n, double _Complex z)
{
    const double _Complex lnz = clog(z);
    const double _Complex lnz2 = lnz*lnz;
    double _Complex sum = em_zeta(n), p = 1.0;

    for (int64_t j = 1; j < n - 1; ++j) {
        p *= lnz/(double)(j);
        sum += em_zeta(n - j)*p;
    }

    p *= lnz/(double)(n - 1);
    sum += (em_harmonic(n - 1) - clog(-lnz))*p;

    p *= lnz/(double)(n);
    sum += em_zeta(0)*p;

    p *= lnz/(double)(n + 1);
    sum += em_zeta(-1)*p;

    for (int64_t j = (n + 3); j < LONG_MAX - 2; j += 2) {
        p *= lnz2/(double)((j - 1)*j);
        const double _Complex old_sum = sum;
        sum += em_zeta(n - j)*p;
        if (sum == old_sum) { break; }
    }

    return sum;
}

   /// returns z^n, treating Re(z) == 0 and Im(z) == 0 in a stable way
double _Complex stable_pow(double _Complex z, int64_t n)
{
    if (cimag(z) == 0) {
        return pow(creal(z), (double)n);
    } else if (creal(z) == 0) {
        const double p = pow(cimag(z), (double)n);
        if (n % 4 == 0) {
            return p;
        } else if (n % 2 == 0) {
            return -p;
        } else if ((n - 1) % 4 == 0) {
            return p * I;
        }
        return -p * I;
    }
    return cpow(z, n);
}

   /// Series expansion of Li_n(z) around z ~ 1, n < 0
double _Complex Li_unity_neg(int64_t n, double _Complex z)
{
    double _Complex lnz = clog(z);
    double _Complex lnz2 = lnz*lnz;
    double _Complex sum = tgamma(1 - (double)n)*stable_pow(-lnz, n - 1);
    double _Complex lnzk, sum_old, term;
    int64_t k;

    if (em_iseven(n)) {
        lnzk = lnz;
        k = 1;
    } else {
        lnzk = lnz2;
        sum += em_zeta(n);
        k = 2;
    }

    do {
        term = em_zeta(n - k)/em_factorial((double)k)*lnzk;
        if (!is_finite(term)) { break; }
        sum_old = sum;
        sum += term;
        lnzk *= lnz2;
        k += 2;
    } while (sum != sum_old);

    return sum;
}

/// returns remainder from inversion formula
double _Complex Li_rest(int64_t n, double _Complex z)
{
    double _Complex lnz = clog(-z);
    double _Complex lnz2 = lnz*lnz;
    const int64_t kmax = em_iseven(n) ? n/2 : (n - 1)/2;
    double _Complex p = em_iseven(n) ? 1.0 : lnz;
    double _Complex sum = 0, old_sum;

    for (int64_t k = kmax; k != 0; --k) {
        const double ifac = 1/em_factorial((double)n - 2*(double)k);
        if (ifac == 0) { return 2.0*sum; }
        sum += em_neg_eta(2*k)*ifac*p;
        p *= lnz2;
        if (sum == old_sum) { break; }
    }

    return 2.0*sum - p/em_factorial((double)n);
}

double norm(double _Complex z){
    return creal(z) * creal(z) + cimag(z) * cimag(z);
}

double _Complex em_li(int64_t n, double _Complex z)
{
   if (isnan(creal(z)) || isnan(cimag(z))) {
      return em_nan();
   } else if (isinf(creal(z)) || isinf(cimag(z))) {
      return -em_inf();
   } else if (z == 0.0) {
      return z;
   } else if (z == 1.0) {
      if (n <= 0) {
         return em_inf() + em_inf() * I;
      }
      return em_zeta(n) + cimag(z) * I;
   } else if (z == -1.0) {
      return em_neg_eta(n) + cimag(z) * I;
   } else if (n < -1) {
      // arXiv:2010.09860
      const double nz = norm(z);
      const double nl = norm(clog(z));
      if (4*PI*PI*nz < nl) {
         return Li_series(n, z);
      } else if (nl < 0.512*0.512*4*PI*PI) {
         return Li_unity_neg(n, z);
      }
      const double _Complex sqrtz = csqrt(z);
      return exp2((double)n - 1)*(em_li(n, sqrtz) + em_li(n, -sqrtz));
   } else if (n == -1) {
      return z/((1.0 - z)*(1.0 - z));
   } else if (n == 0) {
      return z/(1.0 - z);
   } else if (n == 1) {
      return -clog(1.0 - z);
   } else if (n == 2) {
      return em_li2((double)z);
   } else if (n == 3) {
      return em_li3((double)z);
   } else if (n == 4) {
      return em_li4((double)z);
   } else if (norm(z) <= 0.75*0.75) {
      return Li_series(n, z);
   } else if (norm(z) >= 1.4*1.4) {
      const double sgn = em_iseven(n) ? -1.0 : 1.0;
      return sgn*Li_series(n, 1.0/z) + Li_rest(n, z);
   }
   return Li_unity_pos(n, z);
}
